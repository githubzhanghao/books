<!DOCTYPE html>
<html>
<head>
	<title>树算法</title>
</head>
<body>

	insert(key):向树中插入一个新的键； <br>		
	search(key):在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；<br>
	inOrderTraverse:通过中序遍历方式遍历所有节点<br>
	preOrderTraverse:通过先序遍历方式遍历所有节点<br>
	postOrderTraverse:通过后序遍历方式遍历所有节点<br>
	min:返回树中最小的值/键<br>
	max:返回树中最大的值/键<br>
	remove:从树中移除某个键<br>

	<script type="text/javascript">
		
		function BinarySearchTree(){

			var Node = function(key){

				this.key = key;
				this.left = null;
				this.right = null;

			};
			var root = null;

			var insertNode = function(node,newNode){
				
				if(newNode.key < node.key){

					if(node.left == null){
						node.left = newNode;
					}
					else{
						insertNode(node.left,newNode);
					}
				}
				else{
					if(node.right == null){
						node.right = newNode;
					}
					else{
						insertNode(node.right,newNode);
					}
				}

			}

			this.insert = function(key){

				var newNode = new Node(key);

				if(root == null){
					root = newNode;
				}
				else{
					insertNode(root,newNode);
				}
			}


			var length = 0;
			var inOrderTraverseNode = function(node,callback){
				console.log('length = ' + ++length);
				if(node !== null){
					console.log('node = '+node.key);
					inOrderTraverseNode(node.left,callback);
					callback(node.key);
					console.log('node.right = '+node.right);
					inOrderTraverseNode(node.right,callback);
				}

			}

			this.inOrderTraverse = function(callback){
				inOrderTraverseNode(root,callback);
			}

		};

		function printNode(value){
			console.log(value);
		}


		var tree = new BinarySearchTree();
		tree.insert(11);
		tree.insert(5);
		tree.insert(7);
		tree.insert(15);
		tree.insert(6);
		// tree.insert(3);
		// tree.insert(9);
		// tree.insert(8);
		// tree.insert(10);
		// tree.insert(13);
		// tree.insert(12);
		// tree.insert(14);
		// tree.insert(20);
		// tree.insert(18);
		// tree.insert(25);


		tree.inOrderTraverse(printNode);






	</script>
</body>
</html>








